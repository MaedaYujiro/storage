\documentclass[uplatex,compress,xcolor=table,dvipdfmx]{beamer}

\usepackage{soh-beamer}
\usepackage{extarrows}
\usepackage{appendixnumberbeamer}
\usepackage{ragged2e}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{nccmath}

\usepackage{algorithm2e}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{here}
\usepackage{cancel}
\renewcommand{\CancelColor}{\color{red}}

\renewcommand{\kanjifamilydefault}{\gtdefault}

\newcommand{\ts}[1]{{\color{red} #1}}
\newcommand{\dlb}[1]{{\color{orange} #1}}
\newcommand{\mm}[1]{{\color{blue} #1}}
\newcommand{\mi}[1]{\mathit{#1}}
% \newtheorem{definition}{Definition}

\makeatletter
\newcommand{\srcsize}{\@setfontsize{\srcsize}{2pt}{2pt}}
\makeatother

\usepackage{xcolor}

\input{macros/macros}
\input{macros/macros-ph.tex}
\input{macros/macros-abstr}
\input{macros/tikzstyles2.tex}
\input{style.tex}
\definecolor{cerise}{rgb}{0.87, 0.19, 0.39}
\definecolor{dartmouthgreen}{rgb}{0.05, 0.5, 0.06}
\definecolor{cerulean}{rgb}{0.0, 0.48, 0.65}
\definecolor{denim}{rgb}{0.08, 0.38, 0.74}
\definecolor{liver}{rgb}{0.33, 0.29, 0.31}
\definecolor{mauvetaupe}{rgb}{0.57, 0.37, 0.43}
\definecolor{persianindigo}{rgb}{0.2, 0.07, 0.48}
\definecolor{regalia}{rgb}{0.32, 0.18, 0.5}
\definecolor{purpleheart}{rgb}{0.41, 0.21, 0.61}
\definecolor{persiangreen}{rgb}{0.0, 0.65, 0.58}

\newcommand{\hilight}[1]{\textcolor{cerulean}{#1}}
\newcommand{\Bhilight}[1]{\textcolor{cerulean}{\textbf{#1}}}
\newcommand{\new}[1]{\textcolor{blue}{#1}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\cerise}[1]{\textcolor{cerise}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\green}[1]{\textcolor{dartmouthgreen}{#1}}
\newcommand{\gris}[1]{{\textcolor{gray}{#1}}}
\newcommand{\mauvetaupe}[1]{\textit{{\textcolor{mauvetaupe}{#1}}}}
\newcommand{\cean}[1]{{\textcolor{cerulean}{#1}}}
\newcommand{\yellow}[1]{{\textcolor{GreenYellow}{#1}}}
%\newcommand{\Blue}[1]{\textcolor[dvipsnames]{Blue}{#1}}

\newcommand{\redunderline}[1]{\textcolor{red}{\underline{\textcolor{black}{#1}}}}


\newcommand{\saf}{\textsf{SAF}}
\newcommand{\sfj}{\textsf{Sat4j}}
\newcommand{\biolqm}{\textsf{BioLQM}}
\newcommand{\cadical}{\textsf{CaDiCaL}}
\newcommand{\sstd}{\textsf{SharpSAT-TD}}
\newcommand{\bddminisat}{\textsf{BDD\_MINISAT\_ALL}}
\newcommand{\bsim}{\textsf{Boolsim}}
\newcommand{\cabean}{\textsf{Cabean}}
\newcommand{\pyb}{\textsf{PyBoolNet}}
\newcommand{\pybshort}{\textsf{PyB.}}
\newcommand{\pys}{\textsf{Pystablemotifs}}
\newcommand{\aeon}{\textsf{AEON}}
\newcommand{\fasps}{\textsf{fASP-s}}
\newcommand{\faspc}{\textsf{fASP-c}}
\newcommand{\faspfull}{\textsf{fASP}}
\newcommand{\pint}{\textsf{Pint}}
\newcommand{\anasp}{\textsf{AN-ASP}}
\newcommand{\todo}[1]{\textcolor{red}{(TODO) #1.}}
\newcommand{\takehide}[1]{\textcolor{blue}{#1}}
\newcommand{\vect}[1]{% この中身は自分の好きなベクトルの表記に置き換える
\overset{\scriptscriptstyle \boldsymbol{\to}}{\boldsymbol {#1}}    % amsmath が必要
}

\newcommand{\bbm}{\textsf{BBM}}
\newcommand{\prand}{\textsf{P-Random}}
\newcommand{\selected}{\textsf{Selected}}

\newcommand{\dc}{\textsf{D.C.}}
\newcommand{\ic}{\textsf{I.C.}}
\newcommand{\hc}{\textsf{H.C.}}
\newcommand{\he}{\textsf{H.E.}}

\newcommand{\ttsat}{\texttt{SAT}}
\newcommand{\ttunsat}{\texttt{UNSAT}}


\usetheme{default}

\author{前田 悠士朗}

\date{番原・宋研究室ゼミ中間発表\\ 2025年11月28日}
\institute{名古屋大学情報学部コンピュータ科学科 情報システム学専攻 番原・宋研究室}
\title{符号化を用いた命題論理式の極大モデルの計算方法と応用}
\begin{document}

\thispagestyle{empty}
\maketitle
\addtocounter{framenumber}{-1}

\section{Main}
\begin{frame}{命題論理式のモデル}
 \begin{itemize}
        \item 命題論理式の充足可能性判定問題をSAT問題といい，通常CNFという形式で記述される.
	\item CNFの解(モデル)が持つ良い性質の例として，\st{極大性}，\st{極小性}があり，それらを満たすモデルを\st{極大モデル}，\st{極小モデル}と呼ぶ．
 \end{itemize}
 \begin{block}{}
  \begin{itemize}
   \item \structure{極大モデル:} 命題論理式$\Phi$のモデル$M$について，$M\subset M'$かつ$M'$も$\Phi$のモデル，という$M'$が存在しないもの.
   \item \structure{極小モデル:} 命題論理式$\Phi$のモデル$M$について，$M''\subset M$かつ$M''$も$\Phi$のモデル，という$M''$が存在しないもの.
  \end{itemize}
 \end{block}
 \begin{itemize}
   \item 極大モデル，極小モデルの応用例
 \begin{itemize}
  \item 多目的最適化ナップサック問題を順序符号化し，極大，極小モデルを列挙することで，パレートフロントを求めることができる.
  \item 整数ナップサック問題を多値符号化し，極大モデルを列挙することで，圧縮解を求めることができる.
 \end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}{先行研究}
 \begin{block}{}
  \begin{enumerate}
   \item [1][Koshimura+,'09]では，SATソルバーを複数回起動し，極小モデルを求める方法が提案された.
   \item [2][足立,'23]では，CNFに以下の変換を施し，SATソルバーを1回起動し，極小モデルを求める方法が提案された.
\vspace{0.1cm}
    \begin{center}
     {\fontsize{10pt}{8pt}\selectfont $M(\Phi )~=~\bigwedge\limits_{p\in Var(\Phi )}~p~\to~ \neg Cl(\Phi ,p)$\\
   $Cl(\Phi ,p)~\equiv ~\bigwedge\limits_{c\in \Phi ,p\in c}~c\backslash \{ p\}$}
    \end{center}
  \end{enumerate}
 \end{block}
    \begin{alertblock}{}
       \begin{itemize}
	\item 既存提案[Koshimura+,'09]では，SATソルバーを複数回起動する必要があった.
       \end{itemize}
    \end{alertblock}
 \begin{itemize}
   \item 先行研究を基にし，極大モデルをSATソルバー1回起動で求める方法に注目した.
 \end{itemize}
\end{frame}

\begin{frame}{研究概要}
   \begin{alertblock}{研究目的}
    \begin{center}
      効果的な極大モデル，極小モデルの計算方法の実現
    \end{center}
   \end{alertblock}
   \begin{itemize}
     \item 本発表では，極大モデルに注目するものとする.
   \end{itemize}
   \begin{block}{研究内容}
    \begin{enumerate}
     \item \ts{SATソルバー1回起動で極大モデルが求まるCNFへの変換方法を考案}
     \begin{itemize}
      \item ある負リテラルとして含まれる変数について，節中の他の変数で節が満たされている時，その変数を真にするような変換.
     \end{itemize}
     \item \st{変換の正しさの証明}
     \begin{itemize}
      \item 変換前後でCNFの充足可能性は保持されることの証明.
      \item 変換後のCNFのモデルの集合が，変換前のCNFの極大モデルの集合と一致することの証明.
     \end{itemize}
    \end{enumerate}
   \end{block}
\end{frame}

\begin{frame}{提案変換}
 \begin{alertblock}{アイデア}
  ある変数が負リテラルとして含まれる全ての節において，節中の他の変数で節が満たされている場合，その変数を真にすることで，\ts{できるだけ多くの変数を真にする}.
 \end{alertblock}
 \begin{exampleblock}{}
  \begin{itemize}
   \item 与えられたCNFを$\Phi $，変換後のCNFを$\Omega $ とすると，提案変換は，$\Phi$に以下のような制約$M(\Phi )$ を追加し，$\Omega = \Phi \land M(\Phi )$ とするものである.
  \end{itemize}
  \begin{center}
      {\fontsize{13pt}{15pt}\selectfont $M(\Phi )~=~\bigwedge\limits_{p\in Var(\Phi )}~Cl(\Phi ,\neg p)~\to ~p$\\
      $Cl(\Phi ,\neg p)~\equiv ~\bigwedge\limits_{c\in \Phi ,\neg p\in c}~c\backslash \{ \neg p\}$\\}
  \end{center}
 \end{exampleblock}

%     \vspace{0.5cm}
%     \begin{itemize}
%      \item $Cl(\Phi ,\neg p)$ は，変数$p$ を負リテラルとして含む節の集合のそれぞれの節
% から，負リテラル$\neg p$ を除いたものの連言である．
%      \item $M(\Phi )$は，$Cl(\Phi ,\neg p)$が充足される場合，変数$p$が充足される，という制約のすべての変数についての連言である.
%     \end{itemize}

\end{frame}

\begin{frame}{提案変換の説明}
 \begin{exampleblock}{}
  \begin{itemize}
   \item 与えられたCNFを$\Phi $，変換後のCNFを$\Omega $ とすると，提案変換は，$\Phi$に以下のような制約$M(\Phi )$ を追加し，$\Omega = \Phi \land M(\Phi )$ とするものである.
  \end{itemize}
  \begin{center}
      {\fontsize{13pt}{15pt}\selectfont $M(\Phi )~=~\bigwedge\limits_{p\in Var(\Phi )}~Cl(\Phi ,\neg p)~\to ~p$\\
      $Cl(\Phi ,\neg p)~\equiv ~\bigwedge\limits_{c\in \Phi ,\neg p\in c}~c\backslash \{ \neg p\}$\\}
  \end{center}
 \end{exampleblock}
 \only<1-3>{
  \begin{itemize}
   \item $Cl(\Phi ,\neg p)$は，変数$p$が負リテラルとして含まれている全ての節から$\neg p$を除いたものの連言である.
   \item 例：$\Phi ~=~ (p\lor q\lor r)\land (\neg {\textcolor<2>{red}p} \lor q)\land (\neg {\textcolor<3>{red}p} \lor \neg q \lor r)$の場合，
\vspace{0.2cm}
   \begin{center}
    $Cl(\Phi ,\neg p)~=~$\pause${\textcolor<2>{blue}q}~\land~$\pause$(\neg {\textcolor<3>{blue}q} \lor {\textcolor<3>{blue}r})$
   \end{center}
  \end{itemize}
  }
  \only<4>{
   \begin{itemize}
    \item $M(\Phi )$は，全ての変数$p$において，$Cl(\Phi ,\neg p)$満たされれば，$p$を真とするという制約の連言である.
    \item 例：$\Phi ~=~ (p\lor q\lor r)\land (\neg p \lor q)\land (\neg p \lor \neg q \lor r)$の場合，
     \begin{center}
      $Cl(\Phi , \neg p)~=~q \land (\neg q \lor r)$\\
      $M(\Phi )~=~(q \land (\neg q \lor r))\to p$より，\\
      $(q,r)~=~(1,1)$の時，$p$は真になるという制約が追加される.
     \end{center}
   \end{itemize}
  }
\end{frame}

\begin{frame}{提案変換の説明(例)}
 \begin{itemize}
  \item 例えば変換前のCNFを以下の$\Phi$とすると，提案変換で追加する\\
制約$M(\Phi)$は以下のようになる．
 \end{itemize}
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{block}{元のCNF$\Phi$}
	 \begin{center}
	  $\neg {\textcolor<2>{red}a}\lor b\lor \neg {\textcolor<4>{red}c}$\\
	  $\neg {\textcolor<3>{red}b} \lor \neg {\textcolor<4>{red}c}$\\
	  $\neg {\textcolor<4>{red}c} \lor d$	  
	 \end{center}
	\end{block}
      \end{column}
      \begin{column}{0.4\textwidth}
        \begin{block}{追加する節集合$M(\Phi )$}
	 \begin{center}
          \onslide<2->{
	  $(b\lor \neg c) \to {\textcolor<2>{red}a}$}\\
          \onslide<3->{
	  $\neg c \to {\textcolor<3>{red}b}}$\\
          \onslide<4->{
	  $((\neg a \lor b)\land \neg b \land d) \to {\textcolor<4>{red}c}$}\\
          \onslide<5->{
	  $\top \to {\textcolor<5>{red}d}~~(\equiv d)$}
	 \end{center}
	\end{block}
      \end{column}
    \end{columns}

 \only<1>{
  \vspace{0.2cm}
    \begin{itemize}
     \item $\Phi $のモデルは
    \end{itemize}
    \begin{center}
     $(a,b,c,d)~=~(0,0,0,0),(0,0,0,1),(0,1,0,0),(1,0,0,0),$\\
     $(0,1,0,1),(1,0,0,1),(1,1,0,1)$
    \end{center}
 }

 \only<2>{
  \vspace{0.2cm}
  \begin{itemize}
   \item 変数$a$は一つの節に負リテラルとしてのみ含まれている.
   \item $(b\lor \neg c)$を満たすのは，$(b,c)~=~(0,0),(1,0),(1,1)$であり，この時$a~=~1$でなければならない.
   \item $\Phi $のモデルのうち，追加された制約で以下のモデルが制限される.
  \end{itemize}
    \begin{center}
     $(a,b,c,d)~=~\cancel{(0,0,0,0)},\cancel{(0,0,0,1)},\cancel{(0,1,0,0)},(1,0,0,0),$\\
     $\cancel{(0,1,0,1)},(1,0,0,1),(1,1,0,1)$
    \end{center}
 }

 \only<3>{
  \vspace{0.2cm}
  \begin{itemize}
   \item 変数$b$は一つの節に正リテラルとして，一つの節に負リテラルとして含まれている.
   \item $\neg c$を満たすのは，$c~=~0$であり，この時$b~=~1$でなければならない.
   \item $\Phi $のモデルのうち，追加された制約で以下のモデルが制限される.
  \end{itemize}
    \begin{center}
     $(a,b,c,d)~=~\cancel{\blue{(0,0,0,0)}},\cancel{\blue{(0,0,0,1)}},\blue{(0,1,0,0)},\cancel{(1,0,0,0)},$\\
     $\blue{(0,1,0,1)},\cancel{(1,0,0,1)},(1,1,0,1)$
    \end{center}
 }

 \only<4>{
  \vspace{0.2cm}
  \begin{itemize}
   \item 変数$c$は複数の節に負リテラルとして含まれている.
   \item $((\neg a \lor b)\land \neg b \land d)$を満たすのは，$(a,b,d)~=~(0,0,1)$であり，この時$c~=~1$でなければならない.
   \item $\Phi $のモデルのうち，追加された制約で以下のモデルが制限される.
  \end{itemize}
    \begin{center}
     $(a,b,c,d)~=~\blue{(0,0,0,0)},\cancel{\blue{(0,0,0,1)}},\blue{(0,1,0,0)},\blue{(1,0,0,0)},$\\
     $\blue{(0,1,0,1)},\blue{(1,0,0,1)},(1,1,0,1)$
    \end{center}
 }

 \only<5>{
  \vspace{0.2cm}
  \begin{itemize}
   \item 変数$d$は正リテラルとしてのみ含まれている.
   \item $(\top \to d) \equiv d$より，必ず$d~=~1$でなければならない.
   \item $\Phi $のモデルのうち，追加された制約で以下のモデルが制限される.
  \end{itemize}
    \begin{center}
     $(a,b,c,d)~=~\cancel{\blue{(0,0,0,0)}},\blue{(0,0,0,1)},\cancel{\blue{(0,1,0,0)}},\cancel{\blue{(1,0,0,0)}},$\\
     $\blue{(0,1,0,1)},\blue{(1,0,0,1)},(1,1,0,1)$
    \end{center}
 }
  \only<6>{
  \begin{itemize}
    \item $\Phi $のモデルは
  \end{itemize}
    \begin{center}
     $(a,b,c,d)~=~\blue{(0,0,0,0)},\blue{(0,0,0,1)},\blue{(0,1,0,0)},\blue{(1,0,0,0)},$\\
     $\blue{(0,1,0,1)},\blue{(1,0,0,1)},(1,1,0,1)$
    \end{center}
    \begin{itemize}
     \item $\Omega~=~\Phi \land M(\Phi)$のモデルは
    \end{itemize}
    \begin{center}
     $(a,b,c,d)~=~(1,1,0,1)$
    \end{center}
  }
\end{frame}

% \begin{frame}{変換の特徴}
%  \begin{itemize}
%   \item 提案変換について，以下の命題が成り立つ．
%  \end{itemize}
%  \begin{block}{命題1}
%   与えられたCNF$\Phi$に提案変換を施したCNF$\Omega$について，$\Omega$は$\Phi$の充足可能性を保持する.
%  \end{block}
%  \begin{itemize}
%   \item CNF$\Omega$はCNF$\Phi$に節を追加したものなので，命題1より，$\Omega$のモデル集合は$\Phi$のモデル集合に包含される.
%  \end{itemize}
%  \begin{block}{命題2}
%   与えられたCNF$\Phi$，負リテラル同士のループが存在しない場合，$\Phi$に提案変換を施したCNF$\Omega$のモデルの集合は，$\Phi$の極大モデルの集合と一致する.
%  \end{block}
    
% \end{frame}

\begin{frame}{まとめ}
   \begin{alertblock}{}
      \begin{center}
        提案変換の方法について詳しく説明した
      \end{center}
   \end{alertblock}
    \begin{enumerate}
     \item [1]効率的に極大モデルが求まるCNFへの変換方法を考案
     \item [2]変換の正しさの証明
     \begin{itemize}
      \item 変換前後でCNFの充足可能性は保持されることの証明
      \item 変換後のCNFのモデルの集合が，変換前のCNFの極大モデルの集合
と一致することの証明
     \end{itemize}
    \end{enumerate}
  \begin{exampleblock}{今後の課題}
   \begin{itemize}
    \item 極大モデルを求める従来の手法との性能の比較を行う．
    \item 本研究で示した他にも，提案変換によって極小モデル，極大モデルが見つかる有用な応用問題が存在するかを探す．
   \end{itemize}
  \end{exampleblock}
\end{frame}

% -----------------------------
% 参考文献
\begin{frame}[allowframebreaks]{References}
  \scriptsize
  \beamertemplatetextbibitems   % 参考文献アイコンを「文」っぽいものに
  \bibliographystyle{unsrt}     % junsrt が使えるなら戻してOK
  \nocite{*}                    % ← 全件出したいなら追加
  \bibliography{ref}            % ref.bib
\end{frame}


% -----------------------------
% 補足資料
\appendix
\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{}
    \vspace{3em}
    \centering
    \LARGE{補助スライド}
\end{frame}

\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{SATとCNF}
 \begin{block}{SAT(充足可能判定問題)}
  \begin{itemize}
   \item 与えられた命題論理式を充足する値割り当てが存在するかどうかを判定する問題．
   \item 命題論理式を充足する割り当てが存在するとき，充足可能(SAT)であるといい，存在しないとき充足不能(UNSAT)であるという．
   \item 一般的にはCNF(連言標準形)で記述する．
  \end{itemize}
 \end{block}
 \begin{block}{CNF}
  \begin{itemize}
   \item \structure{CNF}は，節の論理積(連言) である．
   \item \structure{節}(clause)は，リテラルの論理和(選言) である．
   \item \structure{リテラル}(literal)は，命題変数，もしくはその否定である．
  \end{itemize}
 \begin{exampleblock}{例}
  $A,B,C$を命題変数としたとき，\\
  $(\neg A\lor B)\land (A\lor C)\land (\neg B \lor \neg C)$
 \end{exampleblock}
 \end{block}
\end{frame}

\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{先行研究の詳細}
 \begin{block}{SATソルバーの複数回起動による極小モデルを求める方法\cite{Koshimura2009minimal} }
  \begin{enumerate}
   \item CNFのモデルを一つ求める．
   \item そのモデルで偽となる変数について，その変数が偽であるという単位節をCNFに追加し，それ以外の変数についてそれらの変数のいずれかが偽となるという制約をCNFに追加する．
   \item 2 で生成したCNFがUNSATであれば，1 で求めたモデルを極小モデルとして出力する．SATであれば，2 の操作を繰り返す．
  \end{enumerate}
 \end{block}
 \begin{block}{SATソルバーの1回起動による極小モデルを求める方法\cite{adachi2024}}
  \begin{itemize}
   \item 与えられたCNFを$\Phi $，変換後のCNFを$\Omega $ とすると，提案変換は，$\Phi$に以下のような制約$M(\Phi )$ を追加し，$\Omega = \Phi \land M(\Phi )$ とするものである.
  \end{itemize}
  \begin{center}
   {\fontsize{10pt}{8pt}\selectfont $M(\Phi )~=~\bigwedge\limits_{p\in Var(\Phi )}~p~\to~ \neg Cl(\Phi ,p)$\\
   $Cl(\Phi ,p)~\equiv ~\bigwedge\limits_{c\in \Phi ,p\in c}~c\backslash \{ p\}$\\}
  \end{center}
 \end{block}
\end{frame}

% \thispagestyle{empty}
% \addtocounter{framenumber}{-1}
% \begin{frame}{提案変換が有効に働く条件の説明}
%  \begin{itemize}
%   \item 古典命題論理では，$\neg x \lor y$という制約を$x\to y$と書き，$x$ならば$y$，という含意の制約を表す.
%   \item CNF中の負リテラルについて，，$\neg x\to \neg y,\neg y\to \neg x$のような，含意の循環が存在しない場合，提案変換で極大モデルが求まる.
%  \end{itemize}
% \end{frame}

\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{提案変換が有効に働く問題の例}
 \begin{block}{CNFの例}
  \vspace{0.2cm}
  \begin{center}
   $\bigg( \bigwedge\limits_i C^+_i\bigg) \land \bigg( \bigwedge\limits_i C^-_j \bigg)$
  \end{center}
  \begin{itemize}
   \item ここで，$C^+_i$は正リテラルのみを含む節で，$C^-_j$は負リテラルのみを含む節である.
  \end{itemize}
 \end{block}
 \begin{block}{応用例}
  \begin{itemize}
   \item 整数ナップサック問題を符号化したCNF
	 \begin{itemize}
	  \item 順序符号化し，提案方法で極大モデルを列挙することで，多重ナップサック問題のパレートフロントが求まる．
	  \item 多値符号化し，提案方法で極大モデルを列挙することで，圧縮解を求めることができる
	 \end{itemize}
  \end{itemize}
 \end{block}
\end{frame}

\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{命題1の証明}
 あるCNF$\Phi$は変数$x$を負リテラルとして含む節の集合\\
 $(\neg x\lor C_1)\land ...\land (\neg x\lor C_m)$と，それ以外の節の集合$A$に分けて以下のように表現できる.\\
 \begin{center}
  $\Phi~=~(\neg x\lor C_1)\land ... \land (\neg x\lor C_m)\land A$
 \end{center}
 ただし，$C_1...~C_m$は，変数$x$を負リテラルとして含む各節から$\neg x$を除いたものである．このとき，本研究の変換は，変数$x$について以下のよう制約を追加する，というのを全ての変数について行うものである．
 \begin{center}
  $m(\Phi ,\neg x)~=~(C_1\land ... \land C_m) \to x$
 \end{center}
 ここで，$\Phi \land m(\Phi ,\neg x)$が$\Phi$の充足可能性を保持していることを証明する．まず， $\Phi$は以下のように変形できる．
 \begin{center}
  $\Phi ~=~ (\neg x\lor (C_1\land ... \land C_m))\land A$
 \end{center}
 さらに，$C~=~(C_1\land ... \land C_m)$とおくと，以下のようになる.
 \begin{center}
  $\Phi ~=~ (\neg x\lor C)\land A$\\
  $m(\Phi ,\neg x)~=~C \to x~=~ x \lor \neg C$
 \end{center}
\end{frame}

\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{命題1の証明（続き）}
 したがって，$(\neg x\lor C)\land A \land (x \lor \neg C)$が，$(\neg x\lor C)\land A$の充足可能性を保持していることを確認すればよい．
 \begin{itemize}
  \item $(\neg x\lor C)\land A$が充足不能なとき\\
        $(\neg x\lor C)\land A \land (x \lor \neg C)$は充足不能である．\\
  \item $(\neg x\lor C)\land A$が充足可能なとき
  \begin{itemize}
   \item $C$が充足可能なとき\\
         $C,A$は$x$を負リテラルとして含まないので，$x$を真としても$C,A$は充足可能である.したがって，$(\neg x\lor C)\land A \land (x \lor \neg C)$は充足可能である.
   \item $C$が充足不能なとき\\
         $x,C$がともに偽であるため，$(\neg x\lor C)\land A \land (x \lor \neg C)$は充足可能である.
  \end{itemize}
 \end{itemize}
以上より，$m(\Phi ,x)$は$\Phi$の充足可能性を保持しており，これは$\Phi$中のすべての変数について同様に成り立つため，提案変換を施した.\\
CNF$\Omega ~=~\Phi \land M(\Phi )$は変換前のCNF$\Phi$の充足可能性を保持する.
\end{frame}

\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{命題2の証明}
 命題1の証明と同様に$C_1...~C_m$を，変数$x$を負リテラルとして含む各節から$\neg x$を除いたものとしたとき，負リテラルに注目した提案変換は，変数$x$について以下のような制約を追加するものであった．
 \begin{center}
  $(C_1\land ... \land C_m)\to x$
 \end{center}
 これは，$C_1...~C_m$が充足されるとき$x$は真である，ということである．これはすべての変数に導入され，一般的には以下のようになる．
 \begin{center}
  $(C_1^1\land ... \land C_1^{m_1})\to x_1$\\
  ...\\
  $(C_n^1\land ... \land C_n^{m_n})\to x_n$
 \end{center}
\end{frame}

\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{命題2の証明（続き）}
 ここで，元の制約$(C_i^1\lor \neg x_i)\land ... \land (C_i^{m_i}\lor \neg x_i)$を考えると，
 \begin{center}
    $x_i\to (C_i^1\land ... \land C_i^{m_i})$
 \end{center}
 これは，$x_i$が真であるとき，$(C_i^1\land ... \land C_i^{m_i})$が充足される，ということである.これも全ての変数で成り立ち，
 \begin{center}
  $x_1 \to (C_1^1\land ... \land C_1^{m_1})$\\
  ...\\
  $x_n \to (C_n^1\land ... \land C_n^{m_n})$
 \end{center}
 というようになる.以上より，$C_i~=~C_1^1\land ... \land C_i^{m_i}$とおくと，
 \begin{center}
  $C_1\leftrightarrow x_1$\\
  ...\\
  $C_n\leftrightarrow x_n$\\
 \end{center}
 これは，CNFのうち，$x_i$を含む節集合が，$x_i$に，真を割り当てたと仮定しても充足される時，$x_i$は真である，ということを意味する．
\end{frame}

\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{循環があると極大モデルが求まらない理由}
 ある極大モデルでもともと真が割り当てられていたある変数の集合$s_1,s_2,...,s_k$において，変数$x_i$についての$C_i$と同様に$s_i$についての$S_i$を定義すると，$s_1,s_2,...,s_k$を同時に偽にし，かつ$S_1,S_2,...,S_k$を同時に真にするような割り当てが存在すれば，極大モデルでないモデルが出現することになる．ここで，ループが存在するとは，ループする変数のパス
 \vspace{0.3cm}
 \begin{center}
  $s_{(1,1)}$\\
  $\downarrow$\\
  $s_{(2,1)},s_{(2,2)},...,s_{(2,t_2)}$\\
  $\downarrow$\\
  ...\\
  $\downarrow$\\
  $s_{(l,1)},s_{(l,2)},...,s_{(l,t_1)}$\\  
  $\downarrow$\\
  $s_{(1,1)}$\\
 \end{center}
 \vspace{0.3cm}
 が存在するということである．
\end{frame}


\thispagestyle{empty}
\addtocounter{framenumber}{-1}
\begin{frame}{循環があると極大モデルが求まらない理由(続き)}
 ただし，これらの変数は同じ変数を含む可能性があり，$s_1,s_2,...,s_k$のいずれかに一致するものとする．極大でないモデルを生み出すために，$s_{(i,1)},s_{(i,2)},...,s_{(i,t_i)}$を偽にする操作を行ったとき，$S_{(i,1)},S_{(i,2)},...,S_{(i,t_i)}$のそれぞれの中で真とする節の中に正リテラルとして現れる変数の集合をさらに偽にする操作が行われる．先述したループする変数のパスが存在すれば，その変数の集合が$\{ s_{(i-1,1)},s_{(i-1,2)},...,s_{(i-1,t_i)}\}$と一致する．その場合，$s_{(1,1)}$から変数を偽にする操作を始めると，ループする変数のパス上を伝播して$s_{(1,1)}$自身へと循環することになり，その場合のみ合$s_1,s_2,...,s_k$を同時に偽にできる．したがって，ループが存在しなければ極大モデルでないモデルを作り出すことができないということになる．\\
以上より，CNF$\Phi$に負リテラルに注目した提案変換CNF$\Omega$に極大モデルでないモデルが現れるには$\Phi$にループが必要であり，$\Phi$がループを含んでいなければ，$\Omega$のモデルは$\Phi$の極大モデルと一致すると言える．
\end{frame}
\end{document}

% \begin{frame}{命題2の証明}
%  \begin{block}{}
%   提案変換を評価するために実験を行った．
%  \end{block}
%  \begin{itemize}
%   \item \structure{比較対象:}既存のSATを複数回起動し，極大モデルを求める方法
%   \item \structure{ベンチマーク:}
%   \item \structure{使用ソルバー:}python3,clasp
%   \item \structure{実験環境:}
%  \end{itemize}
% \end{frame}

% \begin{frame}{SAT問題の極大モデル・極小モデルの例}
%  \begin{block}{極小モデル・極大モデルとは}
%   \begin{itemize}
%    \item \structure{極小モデル:}$~\Phi$のモデル$M$について，$M'\subset M$かつ$M'$も$\Phi$のモデル，という$M'$が存在しないもの.
%    \item \structure{極大モデル:}$~\Phi$のモデル$M$について，$M\subset M''$かつ$M''$も$\Phi$のモデル，という$M''$が存在しないもの.
%   \end{itemize}
%  \end{block}
%  \vspace{0.5cm}
%   例：{\fontsize{13.5pt}{12pt}\selectfont$\Phi~=~p\lor q\lor r$}
%  \vspace{0.3cm}
%   \begin{itemize}
%    \item 満たすモデルは$\{ p\},\{ q\},\{ r\},\{ p,q\},\{ q,r\},\{ r,p\},\{ p,q,r\}$
%    \item \structure{極小モデル:}$~\{ p\},\{ q\},\{ r\}$ 
%    \item \structure{極大モデル:}$~\{ p,q,r\}$
%   \end{itemize}
% \end{frame}